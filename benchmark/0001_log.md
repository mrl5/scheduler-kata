# Benchmark no. 0001

Captured state for commit
[7adc5dacb8](https://github.com/mrl5/scheduler-kata/tree/7adc5dacb81bf42af19d5390f1127b255c397a55)


## Content
* [Main focus](#main-focus)
* [Description](#description)
* [OS](#os)
* [Hardware](#hardware)
* [Setup](#setup)
* [Predicate 0](#predicate-0)
* [Predicate 1](#predicate-1)
* [Predicate 2](#predicate-2)
* [Predicate 3](#predicate-3)
* [Predicate 4](#predicate-4)
* [Additional notes](#additional-notes)


## Main focus
Database


## Description
Analyze query performance when no traffic from REST API and WORKERS are running


### Refs
* https://www.crunchydata.com/developers/playground/query-performance-analytics


## OS
```console
grep PRETTY_NAME /etc/os-release
```
```
PRETTY_NAME="Debian GNU/Linux 11 (bullseye)"
```
```console
uname -a
```
```
Linux debian 5.10.0-23-amd64 #1 SMP Debian 5.10.179-1 (2023-05-12) x86_64 GNU/Linux
```


## Hardware
```console
lscpu
```
```
Architecture:                    x86_64
CPU op-mode(s):                  32-bit, 64-bit
Byte Order:                      Little Endian
<REDACTED>
CPU(s):                          16
<REDACTED>
Model name:                      AMD Ryzen 7 3700X 8-Core Processor
<REDACTED>
```
```console
lsmem | grep -i 'total online'
```
```
Total online memory:      32G
```
```console
lspci  | grep -i nvm
```
```
Non-Volatile memory controller: Samsung Electronics Co Ltd NVMe SSD Controller SM981/PM981/PM983
```


## Setup
1. Use state from benchmark 0000, but clear `pg_stat_statements`
```console
just db-only
export PGPASSWORD=changeme1
psql -h localhost -U postgres -d scheduler-kata \
    -c 'SELECT pg_stat_statements_reset()'
```

2. Spin up containers
```console
cp -v benchmark/0001_env/docker-compose.yml .
cp -v benchmark/0001_env/.env .
just build run
```

3. Some observability
```console
htop
watch -n 1 "./benchmark/0001_env/monitor.sh >> benchmark/0001_env/0001_monitor.log"
export PGPASSWORD=changeme1
watch "psql -h localhost -U postgres -d scheduler-kata \
    -c 'SELECT task_id, is_running FROM tenant_default.queue WHERE is_running'"
```

4. Start benchmark
```console
bash ./benchmark/0001_env/bench.sh
```

5. Stop containers once there is no active task in queue

6. Run db and check predicates
```
just db-only
psql -h localhost -U postgres -d scheduler-kata
```

## Predicate 0
### Basic Linux monitoring
1. Top CPU usage
```
CPU: 43%
```
See [Additional notes](#additional-notes) for root cause
2. Top memory used
```
958748
```

## Predicate 1
### Most time consuming queries
```
\x on
```
```sql
SELECT
  d.datname, round(s.total_exec_time::numeric, 2) AS total_exec_time, s.calls, s.rows,
  round(s.total_exec_time::numeric / calls, 2) AS avg_time,
  round((100 * s.total_exec_time / sum(s.total_exec_time::numeric) OVER ())::numeric, 2) AS percentage_cpu,
  substring(s.query, 1, 500) AS short_query
FROM pg_stat_statements s JOIN pg_database d ON (s.dbid = d.oid)
ORDER BY percentage_cpu DESC
LIMIT 5;
```
```
-[ RECORD 1 ]---+---------------------------------------------------------------------------
datname         | scheduler-kata
total_exec_time | 5504.81
calls           | 213075
rows            | 300
avg_time        | 0.03
percentage_cpu  | 97.57
short_query     | WITH t AS (                                                               +
                |             SELECT task_id as id, task_created_at AS created_at FROM queue+
                |             WHERE is_running = false AND not_before <= now()              +
                |             LIMIT 1 FOR UPDATE SKIP LOCKED                                +
                |         ) UPDATE queue SET is_running = true FROM t                       +
                |         WHERE (task_id, task_created_at) = (t.id, t.created_at)           +
                |         RETURNING task_id, task_created_at
-[ RECORD 2 ]---+---------------------------------------------------------------------------
datname         | scheduler-kata
total_exec_time | 80.47
calls           | 119
rows            | 400
avg_time        | 0.68
percentage_cpu  | 1.43
short_query     | INSERT INTO queue (task_id, task_created_at, not_before)                  +
                |         SELECT id, created_at,                                            +
                |             CASE                                                          +
                |                 WHEN not_before IS NULL                                   +
                |                     THEN created_at                                       +
                |                 ELSE not_before                                           +
                |             END                                                           +
                |         FROM task_state WHERE state = $1::text                            +
                |         ORDER BY id asc LIMIT $2                                          +
                |         ON CONFLICT DO NOTHING
-[ RECORD 3 ]---+---------------------------------------------------------------------------
datname         | scheduler-kata
total_exec_time | 43.15
calls           | 300
rows            | 300
avg_time        | 0.14
percentage_cpu  | 0.76
short_query     | WITH t AS (                                                               +
                |             DELETE FROM queue                                             +
                |             WHERE (task_id, task_created_at) = ($1::uuid, $2::timestamptz)+
                |             RETURNING task_id                                             +
                |         ) UPDATE task SET state = $3::text, inactive_since = now() FROM t +
                |         WHERE id = t.task_id
-[ RECORD 4 ]---+---------------------------------------------------------------------------
datname         | scheduler-kata
total_exec_time | 8.27
calls           | 138
rows            | 138
avg_time        | 0.06
percentage_cpu  | 0.15
short_query     | UPDATE queue SET retries = retries + $3                                   +
                |         WHERE (task_id, task_created_at) = ($1::uuid, $2::timestamptz)    +
                |         RETURNING retries
-[ RECORD 5 ]---+---------------------------------------------------------------------------
<REDACTED> related to psql cli monitoring of benchmark
```


## Predicate 2
### Average Query Execution Time
```sql
SELECT (sum(total_exec_time) / sum(calls))::numeric(6,3) AS avg_execution_time
FROM pg_stat_statements;
```
```
-[ RECORD 1 ]------+------
avg_execution_time | 0.026
```


## Predicate 3
### Queries that write the most to shared_buffers
```sql
SELECT query, shared_blks_dirtied
FROM pg_stat_statements
WHERE shared_blks_dirtied > 0
ORDER BY 2 desc
LIMIT 5;
```
```
-[ RECORD 1 ]-------+----------------------------------------------------------------------------------------------------------------
query               | INSERT INTO queue (task_id, task_created_at, not_before)                                                       +
                    |         SELECT id, created_at,                                                                                 +
                    |             CASE                                                                                               +
                    |                 WHEN not_before IS NULL                                                                        +
                    |                     THEN created_at                                                                            +
                    |                 ELSE not_before                                                                                +
                    |             END                                                                                                +
                    |         FROM task_state WHERE state = $1::text                                                                 +
                    |         ORDER BY id asc LIMIT $2                                                                               +
                    |         ON CONFLICT DO NOTHING
shared_blks_dirtied | 3
-[ RECORD 2 ]-------+----------------------------------------------------------------------------------------------------------------
<REDACTED> pg_cron related
-[ RECORD 3 ]-------+----------------------------------------------------------------------------------------------------------------
<REDACTED> pg_cron related
```


## Predicate 4
### Tables that might be needing an index
```sql
SELECT relname, seq_scan - idx_scan AS too_much_seq,
    CASE WHEN seq_scan - idx_scan > 0 THEN 'Missing Index?' ELSE 'OK' END,
    pg_relation_size(relid) AS rel_size, seq_scan, idx_scan
FROM pg_stat_user_tables
WHERE schemaname <> 'information_schema' AND schemaname NOT LIKE 'pg%'
ORDER BY too_much_seq DESC;
```
```
-[ RECORD 1 ]+-----------------
relname      | queue
too_much_seq | 1394254
case         | Missing Index?
rel_size     | 57344
seq_scan     | 1400007
idx_scan     | 5753
-[ RECORD 2 ]+-----------------
relname      | tenant
too_much_seq | 92
case         | Missing Index?
rel_size     | 8192
seq_scan     | 92
idx_scan     | 0
-[ RECORD 3 ]+-----------------
<REDACTED> pg_cron related table
-[ RECORD 4 ]+-----------------
relname      | task
too_much_seq | 0
case         | OK
rel_size     | 0
seq_scan     | 0
idx_scan     | 0
-[ RECORD 5 ]+-----------------
<REDACTED> sqlx related table
-[ RECORD 6 ]+-----------------
<REDACTED> pg_cron related table
-[ RECORD 7 ]+-----------------
relname      | task_y2023m07
too_much_seq | -3472
case         | OK
rel_size     | 180224
seq_scan     | 2829
idx_scan     | 6301
-[ RECORD 8 ]+-----------------
relname      | task_y2023m08
too_much_seq | -5202
case         | OK
rel_size     | 0
seq_scan     | 604
idx_scan     | 5806
```


## Additional notes
While running `htop` I've noticed that once last task is finished there is a
sudden CPU usage spike that goes down after few seconds and stays at 15%.

Worth noting that 15% of CPU usage is idle usage when workers are running.

Worker threads have 10ms sleep in their "pull from queue" loop.

### Questions
1. Why when workers are busy CPU usage is ~2%?
2. Why idle threads are eating CPU?
3. Why it takes few seconds to lower CPU usage AFTER everything finished?

### Hypothesis
1. Regarding `Q#1` and `Q#2` maybe too high frequency of "pull from queue" loop
   is causing this?
